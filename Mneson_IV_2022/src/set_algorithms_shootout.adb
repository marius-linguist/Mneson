with ada.text_io;use ada.text_io;with Ada.Numerics.Discrete_Random;with Charles.Algorithms.Generic_Set_Intersection;package body Set_Algorithms_Shootout is   Cur : Cursor_Type;   Ok : Boolean;      procedure Generate_Random_Set     (Set : in out Integer_Sets.Set_Type;      Size : Size_Type;      Density : Float := 0.1)   is       subtype Subinteger is Integer range 1 .. Integer (Float (Size) / Density);      package Random_Integers is new Ada.Numerics.Discrete_Random (Subinteger);      use Random_Integers;      Gen : Random_Integers.Generator;   begin     Clear (Set);     Reset (Gen);     Insert (Set, Subinteger'Last / 2, Cur, Ok);     while Length (Set) < Size loop        Insert (Set, Random (Gen), Cur, Ok);     end loop;   end;   procedure Standard_Intersect (S : Set_Array) is   begin      if S'Length > 2 then         declare            Set_1_2 : Set_Type;            procedure Ins (Iter : Cursor_Type) is               begin Insert (Set_1_2, Element (Iter), Cur, Ok); end;            procedure Intersect_1_2 is new Charles.Algorithms.Generic_Set_Intersection              (Iterator_Type => Cursor_Type, Process => Ins, Is_Less => "<");         begin            Intersect_1_2              (First (S (S'First    )), Back (S (S'First    )),               First (S (S'First + 1)), Back (S (S'First + 1)));            Standard_Intersect              (Set_Array'(1 => Set_1_2) & S (S'First + 2 .. S'Last));         end;      elsif S'Length = 2 then         declare            procedure P (Iter : Cursor_Type) is               begin Process (Element (Iter)); end;            procedure Do_It is new Charles.Algorithms.Generic_Set_Intersection              (Iterator_Type => Cursor_Type, Process => P, Is_Less => "<");         begin            Do_It              (First (S (S'First    )), Back (S (S'First    )),               First (S (S'First + 1)), Back (S (S'First + 1)));         end;      elsif S'Length = 1 then         declare            procedure P (Iter : Cursor_Type) is            begin Process (Element (Iter)); end;            procedure Traverse is new Integer_Sets.Generic_Iteration (P);         begin            Traverse (S (S'First));         end;      end if;   end;   type Integer_Array is array (Positive range <>) of Integer;   procedure Find_Min_Max (A : Integer_Array; Min, Max : out Positive) is   begin      Min := A'First;      Max := A'First;      for I in A'First + 1 .. A'Last loop         if A (I) < A (Min) then Min := I;         elsif A (I) > A (Max) then Max := I;         end if;      end loop;   end;            procedure Jackpot_Intersect (S : Set_Array) is   begin      if S'Length >= 2 then         declare            P : array (S'Range) of Cursor_Type;            E : Integer_Array (S'Range);            Min : Positive range S'Range;            Max : Positive range S'Range;         begin            for I in S'Range loop               P (I) := First (S (I));               E (I) := Element (P (I));            end loop;            loop               Find_Min_Max (E, Min, Max);               if Min = Max then -- Jackpot!                  Process (E (E'First));                  for I in S'Range loop                     Increment (P (I));                     E (I) := Element (P (I));                  end loop;               else                  P (Min) := Lower_Bound (S (Min), E (Max));                  E (Min) := Element (P (Min));               end if;            end loop;         exception            when others => null;         end;                     elsif S'Length = 1 then         declare            procedure P (Iter : Cursor_Type) is            begin Process (Element (Iter)); end;            procedure Traverse is new Integer_Sets.Generic_Iteration (P);         begin            Traverse (S (S'First));         end;      end if;   end;end;