with Ada.Strings.Unbounded;with XML_Automaton;package body Mneson.XML is   procedure Inc (X : in out Standard.Integer) is begin X := X + 1; end;   procedure Dec (X : in out Standard.Integer) is begin X := X - 1; end;   function Mnesonise_XML_Stream return Vertex is      use Work;      Content_Indicator : Vertex := To_Vertex ("content+");      Next_Indicator : Vertex := To_Vertex ("next+");      procedure Mnesonise_XML_Token;      package Machine is new XML_Automaton (Mnesonise_XML_Token);      type Stack_Rec is         record            I : Vertex;           -- attribute instance            T : Vertex;           -- attribute type (XML element name)            N : Standard.Natural; -- child count            C : Vertex;           -- last child         end record;      Parent_Stack : array (1 .. Max_Depth) of Stack_Rec;      Top : Standard.Integer range Parent_Stack'Range;      Nul : Vertex;            use Ada.Strings.Unbounded;      use Work;            function To_Vertex (U : Unbounded_String) return Vertex is      begin return To_Vertex (To_String (U));      end;      procedure Mnesonise_XML_Token is         X1, X2 : Vertex;         use Machine;         procedure Connect_Next (X : Vertex) is            Y : Vertex;         begin            Inc (Parent_Stack (Top).N);            if Is_Complex (Parent_Stack (Top).T)            and then Is_Ordered (Parent_Stack (Top).T)            and then Parent_Stack (Top).N > 1 then               Y := New_Vertex;               Connect (Parent_Stack (Top).C, Y);               Connect (Next_Indicator, Y);               Connect (Y, X);            end if;            Parent_Stack (Top).C := X;         end;      begin         if Token_Kind = Start_Tag         or Token_Kind = Empty_Element_Tag then            X1 := New_Vertex;            Connect (Parent_Stack (Top).I, X1);            Connect (To_Vertex (Element_Name), X1);            for I in 1 .. Attribute_Count loop               X2 := New_Vertex;               Connect (X1, X2);               Connect (To_Vertex (Attribute_Name (I)), X2);               Connect (X2, To_Vertex (Attribute_Value (I)));            end loop;            Connect_Next (X1);            if Token_Kind = Start_Tag then               Inc (Top);               Parent_Stack (Top) := (X1, To_Vertex (Element_Name), 0, Nul);            end if;         elsif Token_Kind = End_Tag then            Dec (Top);         elsif Token_Kind = Content_Token then            if Is_Complex (Parent_Stack (Top).T) then               X1 := New_Vertex;               Connect (Parent_Stack (Top).I, X1);               Connect (Content_Indicator, X1);               Connect (X1, To_Vertex (Content));               Connect_Next (X1);            else               Connect (Parent_Stack (Top).I, To_Vertex (Content));            end if;         end if;      end;   begin      Nul := New_Vertex;      Next_Indicator := To_Vertex ("next+");            Top := 1;      Parent_Stack (Top) := (New_Vertex, Nul, 0, Nul);            loop         begin            Machine.Input (Get);         exception            when End_Of_Stream =>               Machine.Finish;               exit;         end;      end loop;            if Top /= 1 then raise XML_Error;      else return Parent_Stack (Top).I;      end if;   end;end;